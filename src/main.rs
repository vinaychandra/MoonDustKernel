//! Project Moondust - Kernel Enty Point.
//! This file is the main entry point for the kernel.

#![no_std]
#![no_main]
#![feature(abi_x86_interrupt)]
#![feature(alloc_error_handler)]
#![feature(asm)]
#![feature(async_closure)]
#![feature(const_btree_new)]
#![feature(const_fn_fn_ptr_basics)]
#![feature(const_fn)]
#![feature(const_mut_refs)]
#![feature(const_raw_ptr_to_usize_cast)]
#![feature(crate_visibility_modifier)]
#![feature(future_poll_fn)]
#![feature(map_first_last)]
#![feature(naked_functions)]
#![feature(new_uninit)]
#![feature(result_into_ok_or_err)]
#![feature(thread_local)]
#![deny(unsafe_op_in_unsafe_fn)]

use arch::{globals, memory::kernel_page_table::KernelPageTable, process::Thread};
use common::ramdisk::{elf_loader::DefaultElfLoader, ustar::UStarArchive};
use core::{
    panic::PanicInfo,
    sync::atomic::{AtomicUsize, Ordering},
};
use elfloader::ElfBinary;
use logging::UnifiedLogger;
use moondust_utils::{
    executor::priority_executor::PriorityExecutor,
    sync::async_channel::{channel, Sender},
};
use spin::Once;

// BOOTBOOT is autogenerated. So, we ignore a bunch of warnings.
#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
mod bootboot;
#[allow(dead_code)]
mod bootboot2;

pub mod arch;
pub mod common;
pub mod logging;

#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate log;
#[macro_use]
extern crate alloc;
#[macro_use]
extern crate const_fn_assert;
#[macro_use]
extern crate bitflags;

/// Logger used by the kernel everywhere. This logger is activated by the architecture
/// level startup once the memory is ready.
pub static KERNEL_LOGGER: UnifiedLogger = UnifiedLogger::new();

static PROCESSOR_COUNT: AtomicUsize = AtomicUsize::new(0);

/// Entry point for the Operating System. This calls into the bootstrap
/// of architecture. This is not expected to return because the architecture
/// calls into [main_bsp] and [main_app].
#[no_mangle]
fn _start() -> ! {
    let this_val = PROCESSOR_COUNT.fetch_add(1, Ordering::SeqCst);

    // We only run bsp on the first processor.
    if this_val == 0 {
        crate::arch::bootstrap::initialize_bootstrap_core();
    } else {
        // loop {} // Do not run AP Core.
        crate::arch::bootstrap::initialize_ap_core(this_val);
    }
}

pub static SCHEDULER: PriorityExecutor<5> = PriorityExecutor::const_new();

/// Main function on AP Processor.
pub fn main_app() -> ! {
    x86_64::instructions::interrupts::enable();
    loop {}
}

/// Main Function on bootstrap processor.
/// This function should not return.
pub fn main_bsp() -> ! {
    SCHEDULER.spawn(2, thread_spawner()).detach();
    SCHEDULER.spawn(2, load_alpha()).detach();
    // x86_64::instructions::interrupts::enable();
    arch::process::block_on(SCHEDULER.run())
}

/// This function is called on panic.
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("Panic: {}", info);
    info!("====== KERNEL_PANIC ======");
    loop {}
}

#[alloc_error_handler]
fn alloc_error_handler(layout: alloc::alloc::Layout) -> ! {
    panic!("allocation error: {:?}", layout)
}

async fn load_alpha() {
    const STACK_SIZE: usize = 10 * 4096 * 1024;

    {
        let mut thread = Thread::new_empty_process(STACK_SIZE).await;
        thread.activate().await;

        let ramdisk: UStarArchive;
        unsafe {
            let initrd_ptr =
                (bootboot::bootboot.initrd_ptr + globals::MEM_MAP_OFFSET_LOCATION) as *const u8;
            ramdisk = UStarArchive::new(initrd_ptr, bootboot::bootboot.initrd_size as usize);
            info!(target: "load_alpha", "Initrd image is {}", ramdisk);
        }

        let file_name = "./userspace/moondust-alpha";
        let file = ramdisk.lookup(file_name).expect("Alpha file not found");
        let binary = ElfBinary::new("moondust-alpha", file).expect("Cannot read the binary");

        {
            let mut pt = thread.get_page_table().lock().await;
            let mut loader = DefaultElfLoader::new(0x0, &mut pt as &mut KernelPageTable);
            binary.load(&mut loader).expect("Binary loading failed");
            info!(target: "load_alpha", 
            "Alpha project loaded. Use comand `add-symbol-file ../../x86_64-moondust-user/debug/moondust-alpha  0x{:x}`", 
            loader.get_exe_location());
        }

        {
            let entry_point = binary.entry_point() as *const ();
            thread.setup_user_ip(entry_point as u64);
        }
        let result = SCHEDULER.spawn(4, thread.run_thread()).await;
        info!("Alpha process exited with return status: {}", result);
    }
}

/// Channel that will spawn new threads onto the scheduler.
pub static SPAWN_THREADS: Once<Sender<(Thread, usize)>> = Once::new();

pub async fn thread_spawner() {
    let (s, r) = channel(100);
    {
        SPAWN_THREADS.call_once(|| s);
    }
    loop {
        let next_thread = r.recv().await;
        let next_thread = next_thread.expect("Sender got dropped!");
        info!(
            target: "spawner",
            "Spawning a new thread with id {} and priority {}",
            next_thread.0.thread_id,
            next_thread.1);
        SCHEDULER
            .spawn(next_thread.1, next_thread.0.run_thread())
            .detach();
    }
}
