//! Project Moondust - Kernel Enty Point.
//! This file is the main entry point for the kernel.

#![no_std]
#![no_main]
#![feature(abi_x86_interrupt)]
#![feature(alloc_error_handler)]
#![feature(asm)]
#![feature(async_closure)]
#![feature(const_btree_new)]
#![feature(const_fn_fn_ptr_basics)]
#![feature(const_fn)]
#![feature(const_mut_refs)]
#![feature(crate_visibility_modifier)]
#![feature(future_poll_fn)]
#![feature(map_first_last)]
#![feature(naked_functions)]
#![feature(new_uninit)]
#![feature(result_into_ok_or_err)]
#![feature(thread_local)]
#![feature(unsafe_block_in_unsafe_fn)]

use alloc::string::String;
use arch::{
    globals,
    process::{preemptable_future::PreemptableFuture, user_future::UserFuture},
};
use common::{
    executor::priority::{Priority, PriorityExecutor},
    graphics,
    memory::{paging::IMemoryMapper, stack::Stack},
    ramdisk,
    ramdisk::elf_loader::DefaultElfLoader,
};
use core::{
    panic::PanicInfo,
    sync::atomic::{AtomicU8, Ordering},
};
use elfloader::ElfBinary;
use log::Log;
use logging::UnifiedLogger;

// BOOTBOOT is autogenerated. So, we ignore a bunch of warnings.
#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
mod bootboot;
mod bootboot2;

pub mod arch;
pub mod common;
pub mod logging;
pub mod sync;
pub mod tasks;

#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate log;
#[macro_use]
extern crate bitflags;
#[macro_use]
extern crate alloc;

/// Logger used by the kernel everywhere. This logger is activated by the architecture
/// level startup once the memory is ready.
pub static KERNEL_LOGGER: UnifiedLogger = UnifiedLogger::new();

static PROCESSOR_COUNT: AtomicU8 = AtomicU8::new(0);

/// Entry point for the Operating System. This calls into the bootstrap
/// of architecture. This is not expected to return because the architecture
/// calls into [main_bsp] and [main_app].
#[no_mangle]
fn _start() -> ! {
    info!("MootDust Kernel: Pre-Init...");

    let this_val = PROCESSOR_COUNT.fetch_add(1, Ordering::SeqCst);

    // We only run bsp on the first processor.
    if this_val == 0 {
        arch::initialize_architecture_bsp();
    } else {
        main_app()
    }
}

/// Main function on AP Processor.
pub fn main_app() -> ! {
    arch::hlt_loop();
}

/// Main Function on bootstrap processor.
/// This function should not return.
pub fn main_bsp(mut mapper: impl IMemoryMapper) -> ! {
    info!("MoonDust Kernel: Main function");

    load_graphics().unwrap();

    // Setup interrupts
    unsafe {
        crate::arch::interrupts::load_interrupts().unwrap();
    }

    info!("Startup completed");

    let exec = PriorityExecutor::new();

    {
        // Load timer process
        exec.spawn(Priority::Medium, tasks::time::process_timer_tasks())
            .detach();
    }

    {
        // Load GUI Logging
        exec.spawn(Priority::Medium, KERNEL_LOGGER.process_gui_logs())
            .detach();
    }

    {
        let f = tasks::keyboard::print_keypresses();
        let new_stack = Stack::new_kernel_stack(globals::PAGE_SIZE * 10);
        let f2 = PreemptableFuture::new(f, new_stack);
        exec.spawn(Priority::Medium, f2).detach();
    }

    info!(
        "Approx startup duration is {:?}",
        crate::common::time::get_uptime()
    );

    info!(
        "Current time is {}",
        crate::common::time::get_current_time()
    );

    unsafe {
        let initrd_ptr = bootboot::bootboot.initrd_ptr + globals::MEM_MAP_LOCATION;
        let ramdisk = ramdisk::ustar::UStarArchive::new(
            initrd_ptr as *const u8,
            bootboot::bootboot.initrd_size as usize,
        );

        info!(target: "main", "initrd image is {}", ramdisk);

        let file_name = "./userspace/sigma_space";
        let file = ramdisk.lookup(file_name).expect("File not found");
        let binary = ElfBinary::new("sigma_space", file).expect("Cannot read the binary");
        let mut loader = DefaultElfLoader::new(0x0, &mut mapper);
        binary.load(&mut loader).expect("Binary loading failed");
        info!(target: "main", "Sigma space loaded");

        let entry_point = binary.entry_point() as *const ();
        let user_stack = Stack::new_user_stack(1 * globals::PAGE_SIZE, &mut mapper);
        let kernel_stack = Stack::new_kernel_stack(3 * globals::PAGE_SIZE);
        let future = UserFuture::new(entry_point, user_stack, kernel_stack);
        exec.spawn(Priority::Medium, future).detach();
    }

    crate::arch::process::block_on(exec.run());
    info!("Main run complete");
    arch::hlt_loop();
}

fn load_graphics() -> Result<(), String> {
    let display;
    unsafe {
        let fb_raw = &bootboot::fb as *const u8 as *mut u32;
        let b = bootboot::bootboot;
        assert!(
            b.fb_scanline == b.fb_width * 4,
            "Scanline must be the same size as width * 4. Not implemented the non equal scenario."
        );
        let fb = core::slice::from_raw_parts_mut(
            fb_raw,
            (bootboot::bootboot.fb_height * bootboot::bootboot.fb_width) as usize,
        );
        display = common::graphics::fb::FrameBrufferDisplay::new(
            fb,
            b.fb_width as u16,
            b.fb_height as u16,
        );
    }

    info!("Initializing the UI");
    let terminal = tui::Terminal::new(display).unwrap();
    info!("Terminal created");
    graphics::gui::initialize(terminal);
    info!("Switching to GUI Logging");

    // Initialize GUI logging.
    KERNEL_LOGGER.enable_gui_logger();
    info!("Project MoonDust");
    info!("Loading services. Please wait.");
    KERNEL_LOGGER.flush();

    Ok(())
}

/// This function is called on panic.
#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("Panic: {}", info);
    info!("====== KERNEL_PANIC ======");
    loop {}
}

#[alloc_error_handler]
#[cfg(not(test))]
fn alloc_error_handler(layout: alloc::alloc::Layout) -> ! {
    panic!("allocation error: {:?}", layout)
}

// TODO: Missing fminf in compiler-builtins for soft-float
// BODY: See https://github.com/rust-lang/rust/issues/62729.
// BODY:
// BODY: As a workaround, we include the functions in libuser for now.
/// Workaround rust-lang/rust#62729
#[no_mangle]
#[doc(hidden)]
pub unsafe extern "C" fn fminf(x: f32, y: f32) -> f32 {
    libm::fminf(x, y)
}

// TODO: Missing fmaxf in compiler-builtins for soft-float
// BODY: See https://github.com/rust-lang/rust/issues/62729.
// BODY:
// BODY: As a workaround, we include the functions in libuser for now.
/// Workaround rust-lang/rust#62729
#[no_mangle]
#[doc(hidden)]
pub unsafe extern "C" fn fmaxf(x: f32, y: f32) -> f32 {
    libm::fmaxf(x, y)
}
