//! Project Moondust - Kernel Enty Point.
//! This file is the main entry point for the kernel.

#![no_std]
#![no_main]
#![feature(abi_x86_interrupt)]
#![feature(alloc_error_handler)]
#![feature(asm)]
#![feature(async_closure)]
#![feature(const_btree_new)]
#![feature(const_fn_fn_ptr_basics)]
#![feature(const_fn)]
#![feature(const_mut_refs)]
#![feature(const_raw_ptr_to_usize_cast)]
#![feature(crate_visibility_modifier)]
#![feature(future_poll_fn)]
#![feature(map_first_last)]
#![feature(naked_functions)]
#![feature(new_uninit)]
#![feature(result_into_ok_or_err)]
#![feature(thread_local)]
#![deny(unsafe_op_in_unsafe_fn)]

use arch::{globals, process::Thread};
use common::ramdisk::{elf_loader::DefaultElfLoader, ustar::UStarArchive};
use core::{
    panic::PanicInfo,
    sync::atomic::{AtomicUsize, Ordering},
};
use elfloader::ElfBinary;
use logging::UnifiedLogger;
use moondust_utils::executor::priority_executor::PriorityExecutor;

// BOOTBOOT is autogenerated. So, we ignore a bunch of warnings.
#[allow(dead_code)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
mod bootboot;
#[allow(dead_code)]
mod bootboot2;

pub mod arch;
pub mod common;
pub mod logging;

#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate log;
#[macro_use]
extern crate alloc;
#[macro_use]
extern crate const_fn_assert;
#[macro_use]
extern crate bitflags;

/// Logger used by the kernel everywhere. This logger is activated by the architecture
/// level startup once the memory is ready.
pub static KERNEL_LOGGER: UnifiedLogger = UnifiedLogger::new();

static PROCESSOR_COUNT: AtomicUsize = AtomicUsize::new(0);

/// Entry point for the Operating System. This calls into the bootstrap
/// of architecture. This is not expected to return because the architecture
/// calls into [main_bsp] and [main_app].
#[no_mangle]
fn _start() -> ! {
    let this_val = PROCESSOR_COUNT.fetch_add(1, Ordering::SeqCst);

    // We only run bsp on the first processor.
    if this_val == 0 {
        crate::arch::bootstrap::initialize_bootstrap_core();
    } else {
        // loop {} // Do not run AP Core.
        crate::arch::bootstrap::initialize_ap_core(this_val);
    }
}

pub static SCHEDULER: PriorityExecutor<5> = PriorityExecutor::const_new();

/// Main function on AP Processor.
pub fn main_app() -> ! {
    x86_64::instructions::interrupts::enable();
    loop {}
}

/// Main Function on bootstrap processor.
/// This function should not return.
pub fn main_bsp() -> ! {
    load_alpha();
    x86_64::instructions::interrupts::enable();
    loop {}
}

/// This function is called on panic.
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    error!("Panic: {}", info);
    info!("====== KERNEL_PANIC ======");
    loop {}
}

#[alloc_error_handler]
fn alloc_error_handler(layout: alloc::alloc::Layout) -> ! {
    panic!("allocation error: {:?}", layout)
}

fn load_alpha() {
    let thread = Thread::new_empty_process();
    // unsafe {
    //     let mut a = crate::common::process::syscall::UserFuture::new(
    //         0,
    //         &mut *(0u64 as *mut arch::process::state::ThreadState),
    //     );
    //     let c = &mut *(0u64 as *mut core::task::Context);
    //     let _ = a.poll(c);
    // }

    let ramdisk: UStarArchive;
    unsafe {
        let initrd_ptr =
            (bootboot::bootboot.initrd_ptr + globals::MEM_MAP_OFFSET_LOCATION) as *const u8;
        ramdisk = UStarArchive::new(initrd_ptr, bootboot::bootboot.initrd_size as usize);
        info!(target: "load_alpha", "Initrd image is {}", ramdisk);
    }

    let file_name = "./userspace/moondust-alpha";
    let file = ramdisk.lookup(file_name).expect("Alpha file not found");
    let binary = ElfBinary::new("moondust-alpha", file).expect("Cannot read the binary");

    let mut pt = thread
        .get_page_table()
        .try_lock()
        .expect("Pagetable is locked");
    let mut mapper = (&mut pt).get_mapper();
    let mut loader = DefaultElfLoader::new(0x0, &mut mapper);
    binary.load(&mut loader).expect("Binary loading failed");
    info!(target: "load_alpha", "Alpha project loaded.");

    // let entry_point = binary.entry_point() as *const ();
}
